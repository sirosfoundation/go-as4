# Phase4 Reference Testing Plan

## Overview

[phase4](https://github.com/phax/phase4) is a mature, lightweight Java AS4 client and server library that we can use as a reference implementation to validate our Go AS4 library. Unlike Domibus (which is a full AS4 gateway), phase4 is a library with clear test cases and examples.

## Phase4 Analysis

### Key Components

1. **AS4ClientUserMessage** - Main client for sending user messages
2. **Test Infrastructure** - Self-contained test server (MockJettySetup)
3. **Crypto Support** - Built on WSS4J/Apache CXF
4. **Test Cases** - Comprehensive test suite covering all scenarios

### Test Patterns Found

From analyzing `AS4ClientUserMessageTest.java`:

1. **Unsigned Message** - Basic UserMessage with payload
2. **Signed Message** - RSA-SHA256 signature with SHA-256 digest
3. **Encrypted Message** - AES-128-GCM encryption
4. **Signed + Encrypted** - Combined security
5. **Attachments** - Single and multiple attachments
6. **Compression** - GZip compression support

### Cryptographic Algorithms

```java
// Signature
ECryptoAlgorithmSign.RSA_SHA_256
ECryptoAlgorithmSignDigest.DIGEST_SHA_256

// Encryption
ECryptoAlgorithmCrypt.AES_128_GCM  // <-- This is what we need!
```

## Proposed Testing Strategy

### Phase 1: Build phase4 Test Server

Create a standalone phase4 server we can test against:

```bash
cd /home/leifj/work/siros.org/eDelivery/phase4
# Build the project
mvn clean install -DskipTests

# Use phase4-server-webapp or create minimal test server
```

### Phase 2: Message Capture & Analysis

1. **Run phase4 tests with debug logging enabled**
   - Capture actual XML messages generated by phase4
   - Compare with our Go implementation
   - Focus on canonicalization output

2. **Enable WSS4J debugging**
   ```java
   System.setProperty("org.apache.ws.security.crypto.merlin.x509" +
                      "cert.provider", "org.apache.ws.security.components" +
                      ".crypto.Merlin");
   ```

3. **Capture canonical SignedInfo**
   - Phase4 will show us exactly what the canonical form should be
   - Compare byte-for-byte with our signedxml output

### Phase 3: Cross-Implementation Tests

Create test cases where:

#### Test 1: Go Client → phase4 Server
```
Go (send) → phase4 MockJettySetup (receive)
- Validates our message generation
- Tests signature verification by mature library
- Tests encryption compatibility
```

#### Test 2: phase4 Client → Go Server  
```
phase4 (send) → Go server (receive)
- Validates our message parsing
- Tests our signature verification
- Tests our decryption
```

#### Test 3: Message Round-Trip
```
Go → phase4 → Go
- Complete validation of both directions
```

## Implementation Plan

### Step 1: Extract Phase4 Test Messages

Create a Java program to dump phase4 messages:

```java
package org.example;

import com.helger.phase4.client.AS4ClientUserMessage;
import com.helger.phase4.crypto.*;
import com.helger.phase4.model.ESoapVersion;
import com.helger.phase4.model.message.MessageHelperMethods;
import com.helger.phase4.util.AS4ResourceHelper;
import com.helger.security.keystore.*;

public class Phase4MessageDumper {
    public static void main(String[] args) throws Exception {
        AS4ResourceHelper resHelper = new AS4ResourceHelper();
        
        AS4ClientUserMessage client = new AS4ClientUserMessage(resHelper);
        client.setSoapVersion(ESoapVersion.SOAP_12);
        client.setAction("TestAction");
        client.setServiceType("MyServiceType");
        client.setServiceValue("http://test.example.org/service");
        client.setConversationID(MessageHelperMethods.createRandomConversationID());
        client.setFromRole("http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/initiator");
        client.setFromPartyID("go-as4");
        client.setToRole("http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/responder");
        client.setToPartyID("domibus");
        
        // Set up keystore
        IKeyStoreAndKeyDescriptor ksd = KeyStoreAndKeyDescriptor.builder()
            .type(EKeyStoreType.JKS)
            .path("keys/dummy-pw-test.jks")
            .password("test")
            .keyAlias("ph-as4")
            .keyPassword("test")
            .build();
        
        client.setCryptoFactory(new AS4CryptoFactoryInMemoryKeyStore(ksd, null));
        client.cryptParams().setAlias(ksd.getKeyAlias());
        
        // Sign
        client.signingParams()
              .setAlgorithmSign(ECryptoAlgorithmSign.RSA_SHA_256)
              .setAlgorithmSignDigest(ECryptoAlgorithmSignDigest.DIGEST_SHA_256);
        
        // Build and dump message
        AS4ClientBuiltMessage msg = client.buildMessage(
            MessageHelperMethods.createRandomMessageID(), 
            null
        );
        
        System.out.println("=== PHASE4 GENERATED MESSAGE ===");
        System.out.println(EntityUtils.toString(msg.getHttpEntity()));
    }
}
```

### Step 2: Comparative Canonicalization Test

Create a test that:
1. Generates identical SignedInfo structure in both Go and Java
2. Canonicalizes using both implementations
3. Compares byte-for-byte

```go
// tests/phase4-compat/canonicalization_test.go
func TestCanonicalizationCompatibility(t *testing.T) {
    // Read SignedInfo XML generated by phase4
    phase4Canonical := loadFile("testdata/phase4-canonical-signedinfo.txt")
    
    // Generate same structure in Go
    signedInfo := createTestSignedInfo()
    
    // Canonicalize with signedxml
    transformXML := `<ec:InclusiveNamespaces xmlns:ec="http://www.w3.org/2001/10/xml-exc-c14n#" PrefixList="env"/>`
    c14n := signedxml.ExclusiveCanonicalization{}
    goCanonical, err := c14n.ProcessElement(signedInfo, transformXML)
    require.NoError(t, err)
    
    // Compare byte-for-byte
    assert.Equal(t, string(phase4Canonical), goCanonical)
}
```

### Step 3: Run phase4 Server for Integration Tests

```java
// Create minimal phase4 server
package org.example;

import com.helger.phase4.server.MockJettySetup;

public class Phase4TestServer {
    public static void main(String[] args) throws Exception {
        System.out.println("Starting phase4 test server...");
        MockJettySetup.startServer();
        System.out.println("Server running at: " + 
            MockJettySetup.getServerAddressFromSettings());
        
        // Keep running
        Thread.currentThread().join();
    }
}
```

Then test against it:
```go
func TestGoClientWithPhase4Server(t *testing.T) {
    // Send from Go client to phase4 server
    client := as4.NewClient()
    resp, err := client.SendMessage("http://localhost:8080/as4", msg)
    require.NoError(t, err)
    
    // phase4 will send receipt if message is valid
    assert.Contains(t, string(resp), "Receipt")
}
```

### Step 4: Root Cause Analysis Tools

Create debugging tools:

```go
// cmd/debug-canonical/main.go
// Tool to show canonical form of SignedInfo
func main() {
    signedInfo := loadSignedInfoFromFile(os.Args[1])
    
    fmt.Println("=== Using signedxml ===")
    c14n := signedxml.ExclusiveCanonicalization{}
    canonical, _ := c14n.ProcessElement(signedInfo, transformXML)
    fmt.Println(canonical)
    fmt.Println("\n=== Hex dump ===")
    fmt.Println(hex.Dump([]byte(canonical)))
}
```

## Expected Outcomes

### Success Criteria

1. ✅ phase4 accepts our signed messages
2. ✅ phase4 accepts our encrypted messages  
3. ✅ We can verify phase4 signatures
4. ✅ We can decrypt phase4 encrypted messages
5. ✅ Canonical SignedInfo matches byte-for-byte

### Current Issue Diagnosis

Based on Domibus logs showing "The signature or decryption was invalid", the most likely issues are:

1. **Canonicalization mismatch** - Our C14N output differs from WSS4J/CXF
2. **Namespace handling** - InclusiveNamespaces not correctly applied
3. **Digest mismatch** - References being canonicalized differently

Phase4 will help us identify which because:
- It's open source - we can debug the Java code
- It uses same WSS4J/CXF as Domibus
- It has clear test cases we can replicate
- We can capture actual XML at each step

## Next Steps

1. **Build phase4** - `mvn clean install`
2. **Run message dumper** - Capture actual phase4 message
3. **Compare XML** - Side-by-side with our Go output
4. **Focus on SignedInfo** - Compare canonical forms
5. **Run phase4 server** - Test our client against it
6. **Debug with phase4 source** - Step through their verification

## Files to Create

```
/home/leifj/work/siros.org/eDelivery/
├── phase4/                    (already cloned)
├── phase4-tools/              (new)
│   ├── message-dumper/
│   │   └── Phase4MessageDumper.java
│   ├── test-server/
│   │   └── Phase4TestServer.java
│   └── pom.xml
└── go-as4/
    └── tests/
        └── phase4-compat/
            ├── canonicalization_test.go
            ├── integration_test.go
            └── testdata/
                ├── phase4-signed-message.xml
                ├── phase4-canonical-signedinfo.txt
                └── phase4-signature-value.b64
```

## Benefits Over Domibus Testing

1. **Source Code Access** - Can debug Java implementation
2. **Simpler Setup** - No Docker, database, P-Mode complexity
3. **Clear Test Cases** - Well-documented test scenarios
4. **Fast Iteration** - Lightweight server, quick restarts
5. **Message Dumps** - Easy to capture and compare messages
6. **Same Crypto Library** - Uses WSS4J like Domibus

This approach will definitively answer whether our signatures are correct or if there's a canonicalization issue.
